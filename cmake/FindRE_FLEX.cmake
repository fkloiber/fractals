#.rst:
# FindRE_FLEX
# --------
#
# Find reflex executable and provides a macro to generate custom build rules
#
#
#
# The module defines the following variables:
#
# ::
#
#   RE_FLEX_FOUND - true is reflex executable is found
#   RE_FLEX_EXECUTABLE - the path to the reflex executable
#   RE_FLEX_VERSION - the version of reflex
#   RE_FLEX_LIBRARIES - The reflex libraries
#   RE_FLEX_INCLUDE_DIRS - The path to the reflex headers
#
#
#
# The minimum required version of reflex can be specified using the
# standard syntax, e.g.  find_package(FLEX 2.5.13)
#
#
#
# If reflex is found on the system, the module provides the macro:
#
# ::
#
#   RE_FLEX_TARGET(Name ReFlexInput ReFlexOutput
#               [COMPILE_FLAGS <string>]
#               [DEFINES_FILE <string>]
#               )
#
# which creates a custom command to generate the <ReFlexOutput> file from
# the <ReFlexInput> file.  If COMPILE_FLAGS option is specified, the next
# parameter is added to the reflex command line. If reflex is configured to
# output a header file, the DEFINES_FILE option may be used to specify its
# name. Name is an alias used to get details of this custom command.
# Indeed the macro defines the following variables:
#
# ::
#
#   RE_FLEX_${Name}_DEFINED - true is the macro ran successfully
#   RE_FLEX_${Name}_OUTPUTS - the source file generated by the custom rule, an
#   alias for FlexOutput
#   RE_FLEX_${Name}_INPUT - the reflex source file, an alias for ${FlexInput}
#   RE_FLEX_${Name}_OUTPUT_HEADER - the header reflex output, if any.
#
#
#
# ReFlex scanners oftenly use tokens defined by Bison: the code generated
# by ReFlex depends of the header generated by Bison.  This module also
# defines a macro:
#
# ::
#
#   ADD_RE_FLEX_BISON_DEPENDENCY(ReFlexTarget BisonTarget)
#
# which adds the required dependency between a scanner and a parser
# where <ReFlexTarget> and <BisonTarget> are the first parameters of
# respectively RE_FLEX_TARGET and BISON_TARGET macros.
#
# ::
#
#   ====================================================================
#   Example:
#
#
#
# ::
#
#    find_package(BISON)
#    find_package(RE_FLEX)
#
#
#
# ::
#
#    BISON_TARGET(MyParser parser.y ${CMAKE_CURRENT_BINARY_DIR}/parser.cpp)
#    RE_FLEX_TARGET(MyScanner lexer.l  ${CMAKE_CURRENT_BINARY_DIR}/lexer.cpp)
#    ADD_RE_FLEX_BISON_DEPENDENCY(MyScanner MyParser)
#
#
#
# ::
#
#    include_directories(${CMAKE_CURRENT_BINARY_DIR})
#    add_executable(Foo
#       Foo.cc
#       ${BISON_MyParser_OUTPUTS}
#       ${RE_FLEX_MyScanner_OUTPUTS}
#    )
#   ====================================================================

find_program(RE_FLEX_EXECUTABLE NAMES reflex DOC "path to the reflex executable")
mark_as_advanced(RE_FLEX_EXECUTABLE)

get_filename_component(RE_FLEX_DIR_HINT ${RE_FLEX_EXECUTABLE} DIRECTORY)
get_filename_component(RE_FLEX_DIR_HINT ${RE_FLEX_DIR_HINT} DIRECTORY)

find_path(RE_FLEX_INCLUDE_DIR reflex.h
  HINTS ${RE_FLEX_DIR_HINT}/include/reflex
  DOC "Path to the reflex headers")
find_library(RE_FLEX_LIBRARIES NAMES reflex
  HINTS ${RE_FLEX_DIR_HINT}/lib
  DOC "Libraries to be linked")

get_filename_component(RE_FLEX_INCLUDE_DIR ${RE_FLEX_INCLUDE_DIR} DIRECTORY)

mark_as_advanced(RE_FLEX_INCLUDE_DIR)
mark_as_advanced(RE_FLEX_LIBRARIES)

set(RE_FLEX_INCLUDE_DIRS ${RE_FLEX_INCLUDE_DIR})

if(RE_FLEX_EXECUTABLE)

  execute_process(COMMAND ${RE_FLEX_EXECUTABLE} --version
    OUTPUT_VARIABLE RE_FLEX_version_output
    ERROR_VARIABLE RE_FLEX_version_error
    RESULT_VARIABLE RE_FLEX_version_result
    OUTPUT_STRIP_TRAILING_WHITESPACE)
  if(NOT ${RE_FLEX_version_result} EQUAL 0)
    if(RE_FLEX_FIND_REQUIRED)
      message(SEND_ERROR "Command \"${RE_FLEX_EXECUTABLE} --version\" failed with output:\n${RE_FLEX_version_output}\n${RE_FLEX_version_error}")
    else()
      message("Command \"${RE_FLEX_EXECUTABLE} --version\" failed with output:\n${RE_FLEX_version_output}\n${RE_FLEX_version_error}\nRE_FLEX_VERSION will not be available")
    endif()
  else()
    # older versions of reflex printed "/full/path/to/executable version X.Y"
    # newer versions use "basename(executable) X.Y"
    get_filename_component(RE_FLEX_EXE_NAME_WE "${RE_FLEX_EXECUTABLE}" NAME_WE)
    get_filename_component(RE_FLEX_EXE_EXT "${RE_FLEX_EXECUTABLE}" EXT)
    string(REGEX REPLACE "^.*${RE_FLEX_EXE_NAME_WE}(${RE_FLEX_EXE_EXT})?\"? (version )?([0-9]+[^ ]*)( .*)?$" "\\3"
      RE_FLEX_VERSION "${RE_FLEX_version_output}")
    unset(RE_FLEX_EXE_EXT)
    unset(RE_FLEX_EXE_NAME_WE)
  endif()

  #============================================================
  # RE_FLEX_TARGET (public macro)
  #============================================================
  #
  macro(RE_FLEX_TARGET Name Input Output Header)
    set(RE_FLEX_TARGET_outputs "${Output}")
    set(RE_FLEX_EXECUTABLE_opts "")

    set(RE_FLEX_TARGET_PARAM_OPTIONS)
    set(RE_FLEX_TARGET_PARAM_ONE_VALUE_KEYWORDS
      COMPILE_FLAGS
      DEFINES_FILE
      )
    set(RE_FLEX_TARGET_PARAM_MULTI_VALUE_KEYWORDS)

    cmake_parse_arguments(
      RE_FLEX_TARGET_ARG
      "${RE_FLEX_TARGET_PARAM_OPTIONS}"
      "${RE_FLEX_TARGET_PARAM_ONE_VALUE_KEYWORDS}"
      "${RE_FLEX_TARGET_MULTI_VALUE_KEYWORDS}"
      ${ARGN}
      )

    set(RE_FLEX_TARGET_usage "RE_FLEX_TARGET(<Name> <Input> <Output> [COMPILE_FLAGS <string>] [DEFINES_FILE <string>]")

    if(NOT "${RE_FLEX_TARGET_ARG_UNPARSED_ARGUMENTS}" STREQUAL "")
      message(SEND_ERROR ${RE_FLEX_TARGET_usage})
    else()
      if(NOT "${RE_FLEX_TARGET_ARG_COMPILE_FLAGS}" STREQUAL "")
        set(RE_FLEX_EXECUTABLE_opts "${RE_FLEX_TARGET_ARG_COMPILE_FLAGS}")
        separate_arguments(RE_FLEX_EXECUTABLE_opts)
      endif()
      if(NOT "${RE_FLEX_TARGET_ARG_DEFINES_FILE}" STREQUAL "")
        list(APPEND RE_FLEX_TARGET_outputs "${RE_FLEX_TARGET_ARG_DEFINES_FILE}")
        list(APPEND RE_FLEX_EXECUTABLE_opts --header-file=${RE_FLEX_TARGET_ARG_DEFINES_FILE})
      endif()

      add_custom_command(OUTPUT ${RE_FLEX_TARGET_outputs}
        COMMAND ${RE_FLEX_EXECUTABLE} ${RE_FLEX_EXECUTABLE_opts} -o${Output} --header-file=${Header} ${Input}
        VERBATIM
        DEPENDS ${Input}
        COMMENT "[RE/FLEX][${Name}] Building scanner with reflex ${RE_FLEX_VERSION}"
        WORKING_DIRECTORY ${CMAKE_CURRENT_SOURCE_DIR})

      set(RE_FLEX_${Name}_DEFINED TRUE)
      set(RE_FLEX_${Name}_OUTPUTS ${Output})
      set(RE_FLEX_${Name}_INPUT ${Input})
      set(RE_FLEX_${Name}_COMPILE_FLAGS ${RE_FLEX_EXECUTABLE_opts})
      if("${RE_FLEX_TARGET_ARG_DEFINES_FILE}" STREQUAL "")
        set(RE_FLEX_${Name}_OUTPUT_HEADER "")
      else()
        set(RE_FLEX_${Name}_OUTPUT_HEADER ${RE_FLEX_TARGET_ARG_DEFINES_FILE})
      endif()
    endif()
  endmacro()
  #============================================================


  #============================================================
  # ADD_RE_FLEX_BISON_DEPENDENCY (public macro)
  #============================================================
  #
  macro(ADD_RE_FLEX_BISON_DEPENDENCY ReFlexTarget BisonTarget)

    if(NOT RE_FLEX_${ReFlexTarget}_OUTPUTS)
      message(SEND_ERROR "Re/Flex target `${ReFlexTarget}' does not exist.")
    endif()

    if(NOT BISON_${BisonTarget}_OUTPUT_HEADER)
      message(SEND_ERROR "Bison target `${BisonTarget}' does not exist.")
    endif()

    set_source_files_properties(${RE_FLEX_${ReFlexTarget}_OUTPUTS}
      PROPERTIES OBJECT_DEPENDS ${BISON_${BisonTarget}_OUTPUT_HEADER})
  endmacro()
  #============================================================

endif()

include(FindPackageHandleStandardArgs)
FIND_PACKAGE_HANDLE_STANDARD_ARGS(REFLEX REQUIRED_VARS RE_FLEX_EXECUTABLE RE_FLEX_INCLUDE_DIR RE_FLEX_LIBRARIES
                                         VERSION_VAR RE_FLEX_VERSION)
